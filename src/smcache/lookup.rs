use zerocopy::LayoutVerified;

use crate::{ScopeLookupResult, SourcePosition};

use super::raw;

/// A resolved Source Location  with file, line and scope information.
#[derive(Debug, PartialEq)]
pub struct SourceLocation<'data> {
    /// The source file this location belongs to.
    pub file: Option<&'data str>,
    /// The source line.
    pub line: u32,
    /// The scope containing this source location.
    pub scope: ScopeLookupResult<'data>,
}

type Result<T, E = Error> = std::result::Result<T, E>;

pub struct SmCache<'data> {
    header: &'data raw::Header,
    min_source_positions: &'data [raw::MinifiedSourcePosition],
    orig_source_locations: &'data [raw::OriginalSourceLocation],
    string_bytes: &'data [u8],
}

impl<'data> std::fmt::Debug for SmCache<'data> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SmCache")
            .field("version", &self.header.version)
            .field("mappings", &self.header.num_mappings)
            .field("string_bytes", &self.header.string_bytes)
            .finish()
    }
}

impl<'data> SmCache<'data> {
    pub fn parse(buf: &'data [u8]) -> Result<Self> {
        let (header, buf): (LayoutVerified<_, raw::Header>, _) =
            LayoutVerified::new_from_prefix(buf).ok_or(Error::Header)?;
        let header = header.into_ref();

        if header.magic == raw::SMCACHE_MAGIC_FLIPPED {
            return Err(Error::WrongEndianness);
        }
        if header.magic != raw::SMCACHE_MAGIC {
            return Err(Error::WrongFormat);
        }
        if header.version != raw::SMCACHE_VERSION {
            return Err(Error::WrongVersion);
        }

        let num_mappings = header.num_mappings as usize;
        let string_bytes = header.string_bytes as usize;
        let (min_source_positions, buf) = LayoutVerified::new_slice_from_prefix(buf, num_mappings)
            .ok_or(Error::SourcePositions)?;
        let (orig_source_locations, buf) = LayoutVerified::new_slice_from_prefix(buf, num_mappings)
            .ok_or(Error::SourceLocations)?;
        let string_bytes = buf.get(..string_bytes).ok_or(Error::StringBytes)?;

        Ok(Self {
            header,
            min_source_positions: min_source_positions.into_slice(),
            orig_source_locations: orig_source_locations.into_slice(),
            string_bytes,
        })
    }

    /// Resolves a string reference to the pointed-to `&str` data.
    fn get_string(&self, offset: u32) -> Option<&'data str> {
        let reader = &mut self.string_bytes.get(offset as usize..)?;
        let len = leb128::read::unsigned(reader).ok()? as usize;

        let bytes = reader.get(..len)?;

        std::str::from_utf8(bytes).ok()
    }

    /// Looks up a [`SourcePosition`] in the minified source and resolves it
    /// to the original [`SourceLocation`].
    pub fn lookup(&self, sp: SourcePosition) -> Option<SourceLocation> {
        let idx = match self.min_source_positions.binary_search(&sp.into()) {
            Ok(idx) => idx,
            Err(0) => 0,
            Err(idx) => idx - 1,
        };

        let sl = self.orig_source_locations.get(idx)?;

        let file = self.get_string(sl.file_idx);
        let line = sl.line;

        let scope = match sl.scope_idx {
            raw::GLOBAL_SCOPE_SENTINEL => ScopeLookupResult::Unknown,
            raw::ANONYMOUS_SCOPE_SENTINEL => ScopeLookupResult::AnonymousScope,
            idx => self
                .get_string(idx)
                .map_or(ScopeLookupResult::Unknown, ScopeLookupResult::NamedScope),
        };

        Some(SourceLocation { file, line, scope })
    }
}

#[derive(Debug)]
#[non_exhaustive]
pub enum Error {
    /// The file was generated by a system with different endianness.
    //#[error("endianness mismatch")]
    WrongEndianness,
    /// The file magic does not match.
    //#[error("wrong format magic")]
    WrongFormat,
    /// The format version in the header is wrong/unknown.
    //#[error("unknown SymCache version")]
    WrongVersion,
    Header,
    SourcePositions,
    SourceLocations,
    StringBytes,
}
